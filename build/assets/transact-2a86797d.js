var ut=Object.defineProperty;var pt=(I,t,e)=>t in I?ut(I,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):I[t]=e;var L=(I,t,e)=>(pt(I,typeof t!="symbol"?t+"":t,e),e);import{fy as ct,ae as C,fz as lt,fA as Z,a_ as ht,aD as W,b0 as V,fB as mt,fC as R,fD as j,a$ as wt,fE as ft,fF as yt,fG as It,fH as H,fI as Q,b_ as z,fJ as b,fK as J,T as N,fL as gt,fM as K,p as X,bp as Y,bq as tt,fN as P,bB as et,bh as vt,cg as O,fO as st,fP as kt,fQ as At,fR as x,c6 as at,fS as M,fT as rt,bb as it,fU as A,fV as p,af as Ct,bU as _,bW as Ot,fW as Tt}from"./index-fc282d72.js";var zt=ct(function(I,t,e){I[e?0:1].push(t)},function(){return[[],[]]});const nt=zt,U={value:0};class dt{constructor(t){L(this,"depositCache",{});L(this,"withdrawCache",{});this.type=t}getId(){return`beefy-zap-${this.type}`}isCorrectAmmType(t){return t.type===this.type}async getCommonOptionData(t,e){const n=C(e,t),s=lt(e,n.chainId);if(s===void 0||s.length===0)return null;let o=e.entities.amms.byChainId[n.chainId];if(o===void 0||o.length===0||(o=o.filter(c=>c.type===this.type),o===void 0||o.length===0)||!Z(n)||n.assetIds.length!==2)return null;for(let c=0;c<n.assetIds.length;++c)if(!ht(e,n.chainId,n.assetIds[c]))return console.warn(this.getId(),`${n.assetIds[c]} not loaded`),null;const r=W(e,n.chainId,n.depositTokenAddress);if(!V(r)||!r.ammId)return null;const a=mt(e,r.ammId);if(!a||!this.isCorrectAmmType(a))return null;const i=R(e,n.chainId),d=j(e,n.chainId),u=n.assetIds.map(c=>wt(e,n.chainId,c)),h=ft(u,i),f=yt(e,a.id);if(!f)return null;const l=It(u,i,d);return{vault:n,zapTokens:l,zap:f,amm:a,lpTokens:h,native:d,wnative:i}}async getDepositOptionsFor(t,e){if(t in this.depositCache)return this.depositCache[t];if(!H(e,t))return null;const n=await this.getCommonOptionData(t,e);if(!n)return null;const{vault:s,zapTokens:o,zap:r,amm:a,lpTokens:i}=n;return this.depositCache[s.id]=o.map(d=>{const u=[d].map(h=>h.address.toLowerCase());return{id:Q(this.getId(),t,s.chainId,u),type:"zap",mode:z.Deposit,providerId:this.getId(),vaultId:t,chainId:s.chainId,tokensId:b(s.chainId,u),tokenAddresses:u,zap:r,amm:a,lpTokens:i,fee:U}}),this.depositCache[s.id]}async getDepositQuoteFor(t,e,n){if(!this.isBeefyZapOption(t))throw new Error(`Wrong option type passed to ${this.getId()}`);const s=C(n,t.vaultId);if(!Z(s))throw new Error("Only standard vaults are supported");if(e.length!==1)throw new Error("Only 1 input token supported");const o=J(e);if(o.amount.lte(N))throw new Error("Quote called with 0 input");const r=R(n,s.chainId),a=o.token,i=gt(o.amount,a.decimals),d=K(a,r),u=t.lpTokens.find(m=>m.address.toLowerCase()!==d.address.toLowerCase()),h=X(n,t.chainId),f=W(n,s.chainId,s.depositTokenAddress),l=await Y(h),c=new tt.MultiCall(l,h.multicallAddress);return this.getDepositQuoteForType({web3:l,depositToken:f,chain:h,option:t,swapTokenIn:d,amounts:e,multicall:c,swapTokenOut:u,userAmountInWei:i,vault:s,userInput:o})}async getDepositStep(t,e,n,s){if(!this.isBeefyZapOption(e))throw new Error(`Wrong option type passed to ${this.getId()}`);const o=C(n,e.vaultId),r=t.steps.find(u=>P(u)),a=et(n);if(!r||!P(r))throw new Error("No swap step in zap quote");const i=t.inputs[0],d=vt(i.token);return{step:"zap-in",message:s("Vault-TxnConfirm",{type:s("Deposit-noun")}),action:O.beefIn(o,i.amount,d,r,e.zap,a),pending:!1,extraInfo:{zap:!0,vaultId:o.id}}}async getWithdrawOptionsFor(t,e){if(t in this.withdrawCache)return this.withdrawCache[t];if(!H(e,t))return null;const n=await this.getCommonOptionData(t,e);if(!n)return null;const{vault:s,zap:o,amm:r,lpTokens:a,wnative:i,native:d}=n,u=st(a,i,d).map(l=>l.address),h=[{id:Q(this.getId(),t,s.chainId,u),type:"zap",mode:z.Withdraw,providerId:this.getId(),vaultId:t,chainId:s.chainId,tokensId:b(s.chainId,u),tokenAddresses:u,zap:o,amm:r,lpTokens:a,fee:U}];return st(n.zapTokens,i,d).forEach(l=>{const c=[l].map(m=>m.address.toLowerCase());h.push({id:Q(this.getId(),t,s.chainId,c),type:"zap",mode:z.Withdraw,providerId:this.getId(),vaultId:t,chainId:s.chainId,tokensId:b(s.chainId,c),tokenAddresses:c,zap:o,amm:r,lpTokens:a,fee:U})}),this.withdrawCache[s.id]=h,this.withdrawCache[s.id]}async getWithdrawQuoteFor(t,e,n){if(!this.isBeefyZapOption(t))throw new Error(`Wrong option type passed to ${this.getId()}`);const s=C(n,t.vaultId);if(!Z(s))throw new Error("Only standard vaults are supported");if(e.length!==1)throw new Error("Only 1 input token supported");const o=J(e);if(o.amount.lte(N))throw new Error("Quote called with 0 input");const r=W(n,s.chainId,s.depositTokenAddress);if(!kt(r,o.token))throw new Error(`Invalid input token ${o.token.symbol}`);const a=X(n,t.chainId),i=await Y(a),d=new tt.MultiCall(i,a.multicallAddress),u=R(n,s.chainId),h=j(n,s.chainId),{shareToken:f,sharesToWithdrawWei:l,withdrawnAmountAfterFeeWei:c}=At(o,s,n);let m=null,g=null,k=null;if(t.tokenAddresses.length===1){if(t.tokenAddresses[0].toLowerCase()===r.address.toLowerCase())throw new Error("can not quote for deposit token on zap withdraw");const y=W(n,t.chainId,t.tokenAddresses[0]);k=x(y,u,h),g=K(y,u),m=t.lpTokens.find(w=>w.address.toLowerCase()!==g.address.toLowerCase())}return this.getWithdrawQuoteForType({option:t,web3:i,multicall:d,chain:a,vault:s,amounts:e,shareToken:f,sharesToWithdrawWei:l,withdrawnToken:r,withdrawnAmountAfterFeeWei:c,swapTokenIn:m,swapTokenOut:g,actualTokenOut:k,wnative:u,native:h})}async getWithdrawStep(t,e,n,s){if(!this.isBeefyZapOption(e))throw new Error(`Wrong option type passed to ${this.getId()}`);const o=at(n,e.vaultId),r=t.steps.find(d=>P(d)),a=r&&P(r),i=et(n);return{step:a?"zap-out":"withdraw",message:s("Vault-TxnConfirm",{type:s("Withdraw-noun")}),action:a?O.beefOutAndSwap(o,t.inputs[0],r,e.zap,i):O.beefOut(o,t.inputs[0],e.zap),pending:!1,extraInfo:{zap:a,vaultId:o.id}}}isBeefyZapOption(t){return t.providerId===this.getId()}}class Wt extends dt{constructor(){super("uniswapv2")}async getDepositQuoteForType({web3:t,chain:e,depositToken:n,swapTokenIn:s,swapTokenOut:o,userAmountInWei:r,option:a,vault:i,amounts:d}){const u=M(n.address,a.amm,e),h=new t.eth.Contract(rt,a.zap.zapAddress),[[f]]=await u.updateAllData([[{estimate:h.methods.estimateSwap(i.earnContractAddress,s.address,r.toString(10))}]]);if(!f.estimate)throw new Error("Failed to estimate swap.");const l=new it(f.estimate[0]),c=r.minus(l),{amountOut:m,priceImpact:g}=u.swap(l,s.address,!0),{addAmountA:k,addAmountB:y,liquidity:w}=u.addLiquidity(c,s.address,m);return{id:A(a.id),optionId:a.id,type:"zap",allowances:d.filter(v=>V(v.token)).map(v=>({token:v.token,amount:v.amount,spenderAddress:a.zap.zapAddress})),inputs:d,outputs:[{token:n,amount:p(w,n.decimals)}],priceImpact:g,steps:[{type:"swap",fromToken:s,fromAmount:p(l,s.decimals),toToken:o,toAmount:p(m,o.decimals),priceImpact:g},{type:"build",inputs:[{token:s,amount:p(k,s.decimals)},{token:o,amount:p(y,o.decimals)}],outputToken:n,outputAmount:p(w,n.decimals)},{type:"deposit",token:n,amount:p(w,n.decimals)}]}}async getWithdrawQuoteForType({chain:t,withdrawnToken:e,withdrawnAmountAfterFeeWei:n,shareToken:s,sharesToWithdrawWei:o,actualTokenOut:r,swapTokenIn:a,swapTokenOut:i,option:d,amounts:u,native:h,wnative:f}){const l=M(e.address,d.amm,t);await l.updateAllData();const{amount0:c,amount1:m,token0:g,token1:k}=l.removeLiquidity(n,!0),y=d.lpTokens.find(T=>T.address.toLowerCase()===g.toLowerCase()),w=d.lpTokens.find(T=>T.address.toLowerCase()===k.toLowerCase());if(!y||!w)throw new Error("LP token mismatch");const v=[{token:s,amount:p(o,s.decimals),spenderAddress:d.zap.zapAddress}],F={type:"split",inputToken:e,inputAmount:p(n,e.decimals),outputs:[{token:y,amount:p(c,y.decimals)},{token:w,amount:p(m,w.decimals)}]};if(a===null)return{id:A(d.id),optionId:d.id,type:"zap",allowances:v,inputs:u,outputs:[{token:x(y,f,h),amount:p(c,y.decimals)},{token:x(w,f,h),amount:p(m,w.decimals)}],priceImpact:0,steps:[F]};const B=a.address.toLowerCase()===g.toLowerCase(),G=B?c:m,$=B?m:c,D=G,{amountOut:E,priceImpact:S}=l.swap(D,a.address),q=$.plus(E);return{id:A(d.id),optionId:d.id,type:"zap",allowances:v,inputs:u,outputs:[{token:r,amount:p(q,i.decimals)}],priceImpact:S,steps:[F,{type:"swap",fromToken:a,fromAmount:p(D,a.decimals),toToken:i,toAmount:p(E,i.decimals),priceImpact:S}]}}}class Ft{getId(){return"vault"}async getModeOptionsFor(t,e,n){const s=C(n,e);if(!Z(s))return null;const o=[s.depositTokenAddress];return[{id:Q("vault",e,s.chainId,o),providerId:"vault",vaultId:e,chainId:s.chainId,tokenAddresses:o,tokensId:b(s.chainId,o),type:"vault",mode:t}]}async getDepositOptionsFor(t,e){return this.getModeOptionsFor(z.Deposit,t,e)}async getDepositQuoteFor(t,e,n){if(e.length!==1)throw new Error("Only 1 input token supported");const s=C(n,t.vaultId);return{id:A(t.id),optionId:t.id,type:"vault",allowances:e.filter(o=>V(o.token)).map(o=>({token:o.token,amount:o.amount,spenderAddress:s.earnContractAddress})),inputs:e,outputs:e}}async getDepositStep(t,e,n,s){const o=C(n,e.vaultId);return{step:"deposit",message:s("Vault-TxnConfirm",{type:s("Deposit-noun")}),action:O.deposit(o,t.inputs[0].amount,t.inputs[0].max),pending:!1,extraInfo:{vaultId:o.id}}}async getWithdrawOptionsFor(t,e){return this.getModeOptionsFor(z.Withdraw,t,e)}async getWithdrawQuoteFor(t,e,n){if(e.length!==1)throw new Error("Only 1 input token supported");return{id:A(t.id),optionId:t.id,type:"vault",allowances:[],inputs:e,outputs:e}}async getWithdrawStep(t,e,n,s){const o=at(n,e.vaultId),r=t.inputs[0];return{step:"withdraw",message:s("Vault-TxnConfirm",{type:s("Withdraw-noun")}),action:O.withdraw(o,r.amount,r.max),pending:!1,extraInfo:{vaultId:o.id}}}}class Bt{getId(){return"gov-vault"}async getModeOptionsFor(t,e,n){const s=C(n,e);if(!Ct(s))return null;const o=[s.depositTokenAddress];return[{id:Q(this.getId(),e,s.chainId,o),providerId:this.getId(),vaultId:e,chainId:s.chainId,tokenAddresses:o,tokensId:b(s.chainId,o),type:"gov-vault",mode:t}]}async getDepositOptionsFor(t,e){return this.getModeOptionsFor(z.Deposit,t,e)}async getDepositQuoteFor(t,e,n){if(e.length!==1)throw new Error("Only 1 input token supported");const s=C(n,t.vaultId);return{id:A(t.id),optionId:t.id,type:"gov-vault",allowances:e.filter(o=>V(o.token)).map(o=>({token:o.token,amount:o.amount,spenderAddress:s.earnContractAddress})),inputs:e,outputs:e}}async getDepositStep(t,e,n,s){const o=_(n,e.vaultId);return{step:"deposit-gov",message:s("Vault-TxnConfirm",{type:s("Stake-noun")}),action:O.stakeGovVault(o,t.inputs[0].amount),pending:!1,extraInfo:{vaultId:o.id}}}async getWithdrawOptionsFor(t,e){return this.getModeOptionsFor(z.Withdraw,t,e)}async getWithdrawQuoteFor(t,e,n){if(e.length!==1)throw new Error("Only 1 input token supported");const s=e[0].max,o=[...e];if(s){const r=_(n,t.vaultId),a=Ot(n,r.id),i=W(n,r.chainId,r.earnedTokenAddress);a.gt(N)&&o.push({token:i,amount:a})}return{id:A(t.id),optionId:t.id,type:"gov-vault",allowances:[],inputs:e,outputs:o}}async getWithdrawStep(t,e,n,s){const o=_(n,e.vaultId),r=t.inputs[0];if(t.inputs.every(i=>i.max===!0)){const i=t.outputs.length===2?t.outputs[1]:{token:W(n,o.chainId,o.earnedTokenAddress),amount:N};return{step:"claim-withdraw",message:s("Vault-TxnConfirm",{type:s("Claim-Withdraw-noun")}),action:O.exitGovVault(o),pending:!1,extraInfo:{rewards:{token:i.token,amount:i.amount},vaultId:o.id}}}return{step:"withdraw",message:s("Vault-TxnConfirm",{type:s("Withdraw-noun")}),action:O.unstakeGovVault(o,r.amount),pending:!1,extraInfo:{vaultId:o.id}}}}class Dt extends dt{constructor(){super("solidly")}async getDepositQuoteForType({web3:t,chain:e,depositToken:n,swapTokenIn:s,swapTokenOut:o,userAmountInWei:r,option:a,vault:i,amounts:d}){const u=M(n.address,a.amm,e),h=new t.eth.Contract(rt,a.zap.zapAddress),[[f]]=await u.updateAllData([[{estimate:h.methods.estimateSwap(i.earnContractAddress,s.address,r.toString(10))}]]);if(!f.estimate)throw new Error("Failed to estimate swap.");const l=new it(f.estimate[0]),c=r.minus(l),{amountOut:m,priceImpact:g}=u.swap(l,s.address,!0),{addAmountA:k,addAmountB:y,liquidity:w}=u.addLiquidity(c,s.address,m);return{id:A(a.id),optionId:a.id,type:"zap",allowances:d.filter(v=>V(v.token)).map(v=>({token:v.token,amount:v.amount,spenderAddress:a.zap.zapAddress})),inputs:d,outputs:[{token:n,amount:p(w,n.decimals)}],priceImpact:g,steps:[{type:"swap",fromToken:s,fromAmount:p(l,s.decimals),toToken:o,toAmount:p(m,o.decimals),priceImpact:g},{type:"build",inputs:[{token:s,amount:p(k,s.decimals)},{token:o,amount:p(y,o.decimals)}],outputToken:n,outputAmount:p(w,n.decimals)},{type:"deposit",token:n,amount:p(w,n.decimals)}]}}async getWithdrawQuoteForType({chain:t,withdrawnToken:e,withdrawnAmountAfterFeeWei:n,shareToken:s,sharesToWithdrawWei:o,actualTokenOut:r,swapTokenIn:a,swapTokenOut:i,option:d,amounts:u,native:h,wnative:f}){const l=M(e.address,d.amm,t);await l.updateAllData();const{amount0:c,amount1:m,token0:g,token1:k}=l.removeLiquidity(n,!0),y=d.lpTokens.find(T=>T.address.toLowerCase()===g.toLowerCase()),w=d.lpTokens.find(T=>T.address.toLowerCase()===k.toLowerCase());if(!y||!w)throw new Error("LP token mismatch");const v=[{token:s,amount:p(o,s.decimals),spenderAddress:d.zap.zapAddress}],F={type:"split",inputToken:e,inputAmount:p(n,e.decimals),outputs:[{token:y,amount:p(c,y.decimals)},{token:w,amount:p(m,w.decimals)}]};if(a===null)return{id:A(d.id),optionId:d.id,type:"zap",allowances:v,inputs:u,outputs:[{token:x(y,f,h),amount:p(c,y.decimals)},{token:x(w,f,h),amount:p(m,w.decimals)}],priceImpact:0,steps:[F]};const B=a.address.toLowerCase()===g.toLowerCase(),G=B?c:m,$=B?m:c,D=G,{amountOut:E,priceImpact:S}=l.swap(D,a.address),q=$.plus(E);return{id:A(d.id),optionId:d.id,type:"zap",allowances:v,inputs:u,outputs:[{token:r,amount:p(q,i.decimals)}],priceImpact:S,steps:[F,{type:"swap",fromToken:a,fromAmount:p(D,a.decimals),toToken:i,toAmount:p(E,i.decimals),priceImpact:S}]}}}function ot(I){return I.status==="fulfilled"}class Lt{constructor(){L(this,"providers",[]);L(this,"providersById",{});this.providers.push(new Ft),this.providers.push(new Bt),this.providers.push(new Wt),this.providers.push(new Dt),this.providers.push(new Tt),this.providersById=this.providers.reduce((t,e)=>(t[e.getId()]=e,t),{})}async getDepositOptionsFor(t,e){return(await Promise.all(this.providers.map(s=>s.getDepositOptionsFor(t,e)))).filter(s=>!!s).flat()}async getWithdrawOptionsFor(t,e){return(await Promise.all(this.providers.map(s=>s.getWithdrawOptionsFor(t,e)))).filter(s=>!!s).flat()}async getDepositQuotesFor(t,e,n){const s=await Promise.allSettled(t.map(i=>this.providersById[i.providerId].getDepositQuoteFor(i,e,n))),[o,r]=nt(s,ot),a=o.map(i=>i.value).filter(i=>!!i).flat();if(r.length>0&&console.warn("getDepositQuotesFor failed",r),a.length>0)return a;throw r.length>0?r[0].reason:new Error("No quotes succeeded")}async getWithdrawQuotesFor(t,e,n){const s=await Promise.allSettled(t.map(i=>this.providersById[i.providerId].getWithdrawQuoteFor(i,e,n))),[o,r]=nt(s,ot),a=o.map(i=>i.value).filter(i=>!!i).flat();if(r.length>0&&console.warn("getWithdrawQuotesFor failed",r),a.length>0)return a;throw r.length>0?r[0].reason:new Error("No quotes succeeded")}async getDepositStep(t,e,n,s){return this.providersById[e.providerId].getDepositStep(t,e,n,s)}async getWithdrawStep(t,e,n,s){return this.providersById[e.providerId].getWithdrawStep(t,e,n,s)}}export{Lt as TransactApi};
